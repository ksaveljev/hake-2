{-# LANGUAGE OverloadedStrings #-}
module Client.CL where

import Control.Lens (use, (.=), (^.))
import Control.Monad (unless, liftM, when)
import System.IO (IOMode(ReadWriteMode), hSeek, hSetFileSize, SeekMode(AbsoluteSeek))
import qualified Data.ByteString as B

import Quake
import QuakeState
import CVarVariables
import qualified Constants
import qualified Client.Console as Console
import qualified Client.Key as Key
import qualified Client.Menu as Menu
import qualified Client.SCR as SCR
import qualified Client.V as V
import qualified Client.VID as VID
import qualified Sound.S as S
import qualified Sys.IN as IN
import qualified QCommon.CBuf as CBuf
import qualified QCommon.Com as Com
import qualified QCommon.CVar as CVar
import qualified QCommon.FS as FS
import qualified Util.Lib as Lib

-- Initialize client subsystem.
init :: Quake ()
init = do
    dedicatedValue <- liftM (^.cvValue) dedicatedCVar

    unless (dedicatedValue /= 0) $ do
      Console.init >> S.init >> VID.init >> V.init

      bufData <- use $ globals.netMessageBuffer
      globals.netMessage.sbData .= bufData
      globals.netMessage.sbMaxSize .= B.length bufData

      Menu.init >> SCR.init >> initLocal >> IN.init

      FS.execAutoexec
      CBuf.execute

initLocal :: Quake ()
initLocal = io (putStrLn "CL.initLocal") >> undefined -- TODO

{-
- WriteConfiguration
- 
- Writes key bindings and archived cvars to config.cfg.
-}
writeConfiguration :: Quake ()
writeConfiguration = do
    gamedir <- FS.gameDir
    let path = gamedir `B.append` "/config.cfg"

    f <- Lib.fOpen path ReadWriteMode

    case f of
      Nothing -> do
        Com.printf "Couldn't write config.cfg.\n"
      Just h -> do
        -- IMPROVE: catch exceptions here?
        io $ hSeek h AbsoluteSeek 0
        io $ hSetFileSize h 0

        io $ B.hPut h "// generated by quake, do not modify\n"

        Key.writeBindings h
        Lib.fClose h
        CVar.writeVariables path

frame :: Int -> Quake ()
frame msec = do
    dedicatedValue <- liftM (^.cvValue) dedicatedCVar

    unless (dedicatedValue /= 0) $ do
      io (putStrLn "CL.frame") >> undefined -- TODO

-- Called after an ERR_DROP was thrown.
drop :: Quake ()
drop = do
    clientStatic <- use $ globals.cls
    let state = clientStatic^.csState

    when (state /= Constants.caUninitialized && state /= Constants.caDisconnected) $ do
      disconnect

      -- drop loading plaque unless this is the initial game start
      when ((clientStatic^.csDisableServerCount) /= -1) $
        SCR.endLoadingPlaque -- get rid of loading plaque

{-
- Disconnect
- 
- Goes from a connected state to full screen console state Sends a
- disconnect message to the server This is also called on Com_Error, so it
- shouldn't cause any errors.
-}
disconnect :: Quake ()
disconnect = io (putStrLn "CL.disconnect") >> undefined -- TODO
